# Интернационализация (i18n)

Модуль интернационализации (i18n) предоставляет инструменты для локализации приложения, включая
перевод текстов, форматирование чисел и работу с множественными формами.

## Функциональные возможности

- **Множество словарей** — каждый модуль приложения может подключать свою часть переводов;
- **Словари любой вложенности** — поддержка плоских и вложенных структур словарей;
- **Плюрализация** — поддержка множественных форм для разных языков (1 объект, 2 объекта...)
- **Динамическая загрузка словарей** — словари загружаются по требованию при первом обращении к
  переводу;
- **Подстановка значений** — поддержка шаблонов с именованными {{областями}} для вставки значений;
- **Форматирование чисел** — с учётом локали и других параметров;
- **Автоопределение локали** — на основе заголовка Accept-Language;
- **Сохранение выбранной локали** — в cookies для восстановления при следующих посещениях;
- **Поддержка React Suspense** — для ожидания загрузки словарей;
- **Поддержка серверного рендеринга** — учёт локали на сервере;
- **Типизация** — подсказками на все доступные ключи перевода с учётом вложенности словарей;

## Структура модуля

Модуль состоит из следующих файлов:

- `index.ts` — Экспортирует все компоненты модуля;
- `provider.ts` — Провайдер модуля i18n для регистрации в DI приложения;
- `service.ts` — Основная логика модуля i18n;
- `token.ts` — Токены для внедрения зависимостей;
- `types.ts` — Типы для работы с переводами;
- `use-i18n.ts` — React-хуки для работы с переводами из React компонентов;
- `utils.ts` — Вспомогательные функции;

## Подключение модуля

Модуль i18n необходимо подключить к приложению через DI контейнер (регистрируется провайдер модуля).

```js
// Подключение модуля i18n
import { i18nService } from 'react-solution';

// Регистрация сервиса в DI контейнере
solutions.register(i18nService);
```

После подключения модуль будет доступен по токену `I18N` напрямую и как зависимость.
В React-компонентах лучше использовать хук `useI18n()` или `useTranslate()`.

## Подключение словарей

По умолчанию модуль не содержит словарей переводов, они подключаются отдельно через DI с
использованием токена `I18N_DICTIONARY`.

### Базовое подключение словарей

Словарь — это древовидная структура. Ключи первого уровня используются для указания локали.
Локаль может быть указана в короткой форме без региона, например `ru` вместо `ru-RU`.
Существует общая локаль `*` (или локаль по умолчанию). Если нет перевода в текущей локали, то будет
использоваться перевод из локали `*`. Приложению доступны только те локали, которые будут указаны
в подключенных словарях.

Новые переводы необходимо сначала прописать в локаль `*`, так как по ней определяются доступные
ключи для перевода (автоматический вывод типов). В локаль `*` обычно прописываются переводы на
английском языке, которые также дублируются и под английскую локаль.

Для подключения словаря в приложения необходимо описать провайдер словаря с токеном
`I18N_DICTIONARY`.
Обычно используется провайдер значения `valueProvider()`.

Словарей может быть много и провайдеров словарей тоже, при этом для всех используется токен
`I18N_DICTIONARY`. Но чтобы словари не перетирали друг друга, а объединялись в одни общий словарь,
в провайдерах используется опция `merge`.

```js
// Пример инъекции словарей
import { valueProvider } from 'react-solution';
import { I18N_DICTIONARY } from 'react-solution';

export const translations = valueProvider({
  token: I18N_DICTIONARY,
  value: {
    '*': {
      catalogs: {
        head: {
          title: 'Example catalog'
        }
      }
    },
    ru: {
      catalogs: {
        head: {
          title: 'Пример каталога'
        }
      }
    },
    'en-EN': {},
  },
  merge: true, // Важно! Позволяет объединять словарь с уже существующими при подключении в DI
});
```

После объявления провайдера словаря, его необходимо зарегистрировать в DI контейнере:

```js
// Пример подключения провайдера словаря в DI контейнер
import { translations } from './translations/provider';

solutions.register(translations);
```

Ключи второго уровня используются как пространства именования. 
Например, модуль каталога должен все свои переводы указать по ключу `'catalogs'`.

С ключей второго уровня начинается "путь" на перевод. Тот самый путь, который будет указываться в
функции перевода, например `t('catalogs.head.title')`

#### Синхронное подключение переводов

Переводы можно прописать явно объектом или импортировать синхронно и прописать результат импорта.
Такие переводы будут сразу доступны без ожидания загрузки.

```js
import authEn from '@src/features/example/translations/en.json';

export const translations = valueProvider({
  token: I18N_DICTIONARY,
  value: {
    '*': {
      example: authEn,
    },
  },
  merge: true, // Важно! Позволяет объединять словари с уже существующими
});
```

#### Динамическая загрузка переводов

Для динамической загрузки переводов по ключу второго уровня указывается функция, которая должна 
вернуть promise на объект переводов. Исполнение функции и ожидание загрузки выполнится только 
при попытке перевести фразу с путем, по которому прописана функция.

```js
export const translations = valueProvider({
  token: I18N_DICTIONARY,
  value: {
    '*': {
      example: () => import('@src/features/example/translations/en.json'),
    },
  },
  merge: true, // Важно! Позволяет объединять словари с уже существующими
});
```

### Структура переводов

Словари могут иметь как плоскую, так и вложенную структуру любой глубины. Вложенные структуры
автоматически преобразуются в плоский формат с использованием точечной нотации для ключей.

```js
// Пример словаря с вложенной структурой
export default {
  title: 'Заголовок',
  content: {
    subtitle: 'Подзаголовок',
    description: 'Описание',
    items: {
      one: 'Первый элемент',
      two: 'Второй элемент'
    }
  }
};

// Доступ к вложенным ключам
t('example.content.subtitle'); // 'Подзаголовок'
t('example.content.items.one'); // 'Первый элемент'
```

## React-хуки

### `useI18n`

Хук для получения кода текущей локали `locale`, списка доступных локалей `locales`, функции смены
локали `setLocale()`, функции перевода `t()` и функции форматирования числа с учётом локали `n()`.
Если меняется локаль или словарь, то хук вернёт новую функцию перевода.
При этом компонент перерендерится.

```ts
const { locale, locales, setLocale, t, n } = useI18n();

const title = t(`example.title`);
```

### `useTranslate`

Хук возвращает только функцию перевода `t()` из хука `useI18n`.

```ts
const t = useTranslate();
const title = t(`example.title`);
```

## Функция перевода `t()`

### Базовое использование

```ts
const title = t(`example.title`);
```

### Множественное число (плюрализация)

Для перевода с учётом множественного числа в опции plural указывается число для склонения. В словаре
должны быть переводы под соответствующие множественные формы.

```ts
const countText = t(`example.basket.articles`, { plural: 5 }); // 5 товаров
```

Словарь с учётом плюрализации. В русском языке 3 формы и `other` используется для дробных чисел.
Под другие языки доступны: `zero`, `one`, `two`, `few`, `many`, `other`.
В английском 2 формы: `one` и `other`

```json
{
  "basket": {
    "articles": {
      "one": "товар",
      "few": "товара",
      "many": "товаров",
      "other": "товара"
    }
  }
}
```

Числовое значение можно подставить в перевод в область `{{plural}}`

```json
{
  "count": {
    "one": "Остался {{plural}} рубль!!!",
    "few": "Осталось {{plural}} рубля!!",
    "many": "Осталось {{plural}} рублей!"
  }
}
```

```ts
const countText = t(`example.count`, { plural: 100 }); // Осталось 100 рублей!
```

Плюрализация работает на основе стандарта Intl.PluralRules, который автоматически определяет
правильную форму множественного числа для текущей локали:

```ts
// Примеры для русской локали
t(`example.count`, { plural: 1 }); // Остался 1 рубль!!!
t(`example.count`, { plural: 2 }); // Осталось 2 рубля!!
t(`example.count`, { plural: 5 }); // Осталось 5 рублей!
t(`example.count`, { plural: 11 }); // Осталось 11 рублей!
t(`example.count`, { plural: 21 }); // Остался 21 рубль!!!
t(`example.count`, { plural: 1.5 }); // Осталось 1.5 рубля!! (форма other)
```

### Динамическая загрузка словарей и fallback

При первом обращении к функции перевода динамически подгружается словарь. Если словарь ещё в
процессе
загрузки, то вернётся перевод по умолчанию `fall` (если передан) или код переводимой фразы. Если
словарь текущей локали загружен, но в нём нет перевода, то вернётся перевод из базовой локали.

```ts
const text = t(`example.title`, { fall: 'Title' });
```

Динамическая загрузка словарей происходит автоматически при первом обращении к ключу из
соответствующего пространства имён. Для этого в словаре должна быть указана функция, возвращающая
результат динамического импорта:

```js
export const translations = valueProvider({
  token: I18N_DICTIONARY,
  value: {
    '*': {
      // Динамическая загрузка словаря для пространства имён 'example'
      example: () => import('./translations/en.json'),
    },
    'ru-RU': {
      // Динамическая загрузка словаря для пространства имён 'example'
      example: () => import('./translations/ru.json'),
    }
  },
  merge: true, // Важно! Позволяет объединять словари с уже существующими
});
```

Затем при первом обращении к ключу из этого пространства имён словарь будет загружен:

```ts
// Это вызовет загрузку словаря для пространства имён 'example'
const title = t('example.title');
```

Можно также явно загрузить словарь с помощью метода `load` сервиса I18n:

```ts
const i18n = useSolution(I18N);
await i18n.load('ru-RU', 'example');
```

### Шаблоны с подстановкой значений

Поддерживается шаблон перевода с областями для вставки значений. Именованные области для вставки
значений указываются в строке перевода.

```json
{
  "welcome": "Привет {{name}} {{secondName}}!!!"
}
```

```ts
const text = t(`example.welcome`, { values: { name: 'Василий', secondName: 'Пупкин' } });
```

### React Suspense

По умолчанию поддерживается React `<Suspense>`. Ожидание срабатывает при загрузке динамически
подключенных словарей. Для этого функция `t()` выбрасывает исключение с промисом.

```tsx
<Suspense fallback={<div>Loading...</div>}>
  <Component />
</Suspense>
```

### Указание локали

Можно указать желаемую локаль для перевода. Локаль должна быть определена в инъекции токена
`I18N_DICTIONARY`.

```ts
const text = t(`example.title`, { locale: 'ru-RU' });
```

### Допустимые локали

Можно указать список допустимых локалей для перевода. По умолчанию используются все локали,
определенные в инъекции токена `I18N_DICTIONARY`.

```ts
const text = t(`example.title`, { allowedLocales: ['ru', 'en'] });
```

## Сервис I18n

Сервис I18n предоставляет основную функциональность для работы с переводами. Он доступен через токен
`I18N`.

```ts
import { useSolution } from '../solutions';
import { I18N } from './token';

function MyComponent() {
  const i18n = useSolution(I18N);
  // Использование сервиса I18n
}
```

### Основные методы

#### `setLocale(locale: string)`

Устанавливает текущую локаль.

```ts
i18n.setLocale('ru');
```

#### `translate(key: I18nPath, options?: I18nTranslateOptions): Promise<string>`

Асинхронный метод для перевода текста. Ожидает загрузки словарей перед возвращением перевода.

```ts
const text = await i18n.translate('example.title');
```

#### `translateSync(key: I18nPath, options?: I18nTranslateOptions): string`

Синхронный метод для перевода текста. Если словарь ещё загружается, выбрасывает исключение с
промисом для работы с React Suspense.

```ts
const text = i18n.translateSync('example.title');
```

#### `number(value: number, options?: I18nNumberOptions): string`

Форматирует число с учётом локали.

```ts
const formattedNumber = i18n.number(1000.5); // "1 000,5" для русской локали
```

#### `replace(template: string, values: Record<string, string | number>): string`

Заменяет именованные области в шаблоне на соответствующие значения.

```ts
const text = i18n.replace('Привет {{name}}!', { name: 'Мир' }); // "Привет Мир!"
```

#### `load(locale: string, namespace: string): Promise<void>`

Загружает словарь для указанной локали и пространства имён.

```ts
await i18n.load('ru', 'example');
```

## Типизация

Типы выводятся автоматически на основе базовой локали `*`. Новые словари сперва необходимо
подключать
в базовую локаль. После подключаются переводы под конкретные локали.
За счёт типизации словарей автоматический вывод типов подскажет все доступные ключи из перевода с
учётом вложенности словарей.

### Расширение типов

Для добавления новых пространств имён в типизацию можно расширить интерфейс `I18nNamespaces`:

```ts
declare global {
  interface I18nNamespaces {
    new_namespace: typeof import('./translations/en.json');
  }
}
```

После этого станут доступны пути переводов, начинающиеся с "new_namespace."

### Основные типы

- `I18nPath` - Пути к переводам
- `I18nTranslateOptions` - Опции для функции перевода
- `I18nNumberOptions` - Опции для форматирования чисел
- `I18nState` - Состояние сервиса I18n
- `I18nConfig` - Конфигурация сервиса I18n
- `useI18nReturn` - Возвращаемое значение хука useI18n

## Продвинутые примеры

### Комбинирование возможностей

Можно комбинировать различные возможности модуля i18n для создания сложных переводов:

```ts
// Комбинирование плюрализации и подстановки значений
const message = t('example.cart.summary', {
  plural: items.length,
  values: {
    count: items.length,
    total: n(totalPrice)
  }
});
```

Соответствующий словарь:

```json
{
  "cart": {
    "summary": {
      "zero": "Ваша корзина пуста",
      "one": "В корзине {{count}} товар на сумму {{total}}",
      "few": "В корзине {{count}} товара на сумму {{total}}",
      "many": "В корзине {{count}} товаров на сумму {{total}}"
    }
  }
}
```

### Использование с React Suspense и ErrorBoundary

```tsx
import React, { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useTranslate } from 'react-solution/i18n';

function ProductDetails({ productId }) {
  const t = useTranslate();

  return (
    <div>
      <h1>{t(`products.${productId}.title`)}</h1>
      <p>{t(`products.${productId}.description`)}</p>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary fallback={<div>Ошибка загрузки перевода</div>}>
      <Suspense fallback={<div>Загрузка...</div>}>
        <ProductDetails productId="123" />
      </Suspense>
    </ErrorBoundary>
  );
}
```

### Динамическое переключение локали

```tsx
import React from 'react';
import { useI18n } from 'react-solution/i18n';

function LanguageSwitcher() {
  const { locale, locales, setLocale, t } = useI18n();

  return (
    <div>
      <h2>{t('settings.language')}</h2>
      <select
        value={locale}
        onChange={(e) => setLocale(e.target.value)}
      >
        {locales.map(code => (
          <option key={code} value={code}>
            {t(`locales.${code}`)}
          </option>
        ))}
      </select>
    </div>
  );
}
```
